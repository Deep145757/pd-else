#N canvas 443 23 563 445 10;
#X obj 215 162 hsl 128 15 100 10000 1 0 empty empty empty -2 -8 0 10
#dcdcdc #000000 #000000 0 1;
#X obj 306 4 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc
0;
#N canvas 382 141 749 319 (subpatch) 0;
#X coords 0 -1 1 1 252 42 2 100 100;
#X restore 305 3 pd;
#X obj 345 11 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc
0;
#X obj 23 40 cnv 4 4 4 empty empty Perlin 0 28 2 18 #e0e0e0 #000000
0;
#X obj 458 11 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc
0;
#X obj 478 11 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc
0;
#X obj 464 26 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc
0;
#X obj 75 40 cnv 4 4 4 empty empty noise 0 28 2 18 #e0e0e0 #000000
0;
#X obj 3 416 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020
0;
#X obj 3 301 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000
0;
#X obj 3 352 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000
0;
#X obj 3 387 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000
0;
#X obj 94 361 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0
;
#X obj 92 310 cnv 17 3 34 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0
;
#X text 160 362 signal;
#X text 147 394 1) float;
#X obj 212 186 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
#dcdcdc #000000 #000000 0 256;
#X text 124 311 float/signal;
#X obj 123 40 cnv 4 4 4 empty empty generator 0 28 2 18 #e0e0e0 #000000
0;
#X obj 212 236 else/out~;
#X text 207 394 - sets frequency in hertz (default: nyquist);
#X obj 2 3 cnv 15 301 42 empty empty perlin~ 20 20 2 37 #e0e0e0 #000000
0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1 0 0;
#X restore 2 3 graph;
#X text 271 186 frequency in Hz;
#X text 207 363 - perlin noise signal;
#X text 207 311 - frequency in hertz;
#X obj 212 211 else/perlin~;
#X text 129 327 seed <float> - a float sets seed \, no float sets a
unique internal, f 65;
#N canvas 455 181 698 248 seed 0;
#X text 30 19 Pseudo random number generators like [white~] aren't
true random number generators. Instead \, an algorithm is used to provide
a sequence of numbers that seems random. The same sequence can be reproduced
if you set a "seed" value \, which can be any integer number., f 52
;
#X text 30 91 You can set a seed to [perlin~]'s [white~] noise. Seeds
are kept locally \, which means that if two objects are seeded the
same they will have the same output. Conversely \, you can seed the
same object twice with the same seed to repeat the output., f 52;
#X text 30 162 You can also set a seed with the argument. If you don't
supply it \, each object gets its own internal seed. If you send a
'seed' message without float \, the object also gets a unique seed
value., f 52;
#X obj 383 144 else/downsample~ 1;
#X obj 533 144 else/downsample~ 1;
#X obj 383 184 else/numbox~ 12 12 100 #c0c0c4 #440008 10 0 0 0;
#X msg 533 54 seed 507;
#X msg 383 54 seed;
#X text 593 53 <-- set seed;
#X obj 383 105 else/perlin~ 111;
#X obj 533 105 else/perlin~ 111;
#X obj 533 184 else/numbox~ 12 12 100 #c0c0c4 #440008 10 0 0 0;
#X text 376 23 Sync [perlin~] objects with a seed value;
#X connect 3 0 5 0;
#X connect 4 0 11 0;
#X connect 6 0 9 0;
#X connect 6 0 10 0;
#X connect 7 0 9 0;
#X connect 7 0 10 0;
#X connect 9 0 3 0;
#X connect 10 0 4 0;
#X restore 472 262 pd seed;
#X text 74 86 [perlin~] is an abastraction that implements 1-dimensional
Perlin Noise (a type of gradient noise developed by Ken Perlin). It
uses [white~] as a noise source into a sample and hold function and
generates smoothened functions according to a frequency value in hertz
(values under 0 and above nyquist are aliased)., f 71;
#X connect 0 0 17 0;
#X connect 17 0 27 0;
#X connect 27 0 20 0;
