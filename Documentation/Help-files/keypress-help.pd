#N canvas 449 37 562 556 10;
#X obj 4 318 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 4 409 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 4 461 cnv 3 550 3 empty empty flags 8 12 0 13 #dcdcdc #000000 0;
#X obj 136 416 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 4 529 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 136 325 cnv 17 3 79 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 4 2 cnv 15 301 42 empty empty keypress 20 20 2 37 #e0e0e0 #000000 0;
#X obj 307 3 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1;
#X restore 3 2 graph;
#X obj 346 10 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc 0;
#X obj 22 39 cnv 4 4 4 empty empty Key\ learn 0 28 2 18 #e0e0e0 #000000 0;
#X obj 459 10 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 479 10 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 516 10 cnv 10 10 10 empty empty Solus' 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 465 25 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 503 25 cnv 10 10 10 empty empty library 0 6 2 13 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 252 42 1 0 0;
#X restore 306 2 graph;
#X text 209 357 query;
#X msg 223 208 query;
#X obj 262 278 else/display;
#X text 245 372 - forget input, f 42;
#X obj 136 438 cnv 17 3 17 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 203 372 forget;
#X text 245 357 - print send stored input on right outlet, f 42;
#X text 215 326 bang -;
#X obj 187 278 else/display;
#X text 155 388 teach <symbol>;
#X text 245 388 - teach a specific key, f 42;
#X text 257 326 activate key learn, f 40;
#X text 170 416 bang/float -;
#X text 194 439 symbol -;
#X text 248 439 learned key, f 41;
#X text 248 417 from learned key depending on the mode, f 41;
#X text 155 341 toggle <float>;
#X text 245 341 - non zero sets to toggle mode, f 42;
#N canvas 674 194 360 265 toggle 0;
#X obj 246 197 else/display;
#X obj 123 197 else/display;
#X text 44 32 In toggle mode you have "1" for when the learned key is pressed and 0 when it is released., f 40;
#X msg 153 112 toggle \$1;
#X obj 153 89 tgl 16 0 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 123 162 else/key.learn a;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 5 0 1 0;
#X connect 5 1 0 0;
#X restore 450 274 pd toggle;
#X msg 187 147 set Space;
#X msg 213 181 learn;
#X msg 144 147 set a;
#X obj 46 256 key;
#X text 250 146 set a specific key;
#X text 52 81 [keypress] uses key presses of a single key to send a bang or a toggle. You can set the key symbol as an argument or ask the object to "learn" a pressed key (useful for kys like "shift" and stuff) \, which is then saved as an argument in the owning patch. Note that autorepeated keys are filtered!, f 73;
#X text 275 176 Whenever the abstraction learns something new \, you'll be prompted to save your patch when you close it \, so it gets saved. After sending "leanr" \, press a key to teach the object., f 42;
#X obj 187 252 else/keypress a;
#X obj 4 495 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X text 155 469 -toggle - sets to toggle output (default bang);
#X text 155 503 1) symbol - sets a key name (default noneg);
#X msg 116 200 set;
#X text 80 199 none;
#X connect 18 0 43 0;
#X connect 36 0 43 0;
#X connect 37 0 43 0;
#X connect 38 0 43 0;
#X connect 43 0 25 0;
#X connect 43 1 19 0;
#X connect 47 0 43 0;
