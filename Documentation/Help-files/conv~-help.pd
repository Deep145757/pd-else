#N canvas 365 52 569 478 10;
#X obj 307 6 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc 0;
#X obj 346 13 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc 0;
#X obj 24 42 cnv 4 4 4 empty empty Partitioned 0 28 2 18 #e0e0e0 #000000 0;
#X obj 110 42 cnv 4 4 4 empty empty convolution 0 28 2 18 #e0e0e0 #000000 0;
#X obj 459 13 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 479 13 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 516 13 cnv 10 10 10 empty empty Solus' 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 465 28 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 503 28 cnv 10 10 10 empty empty library 0 6 2 13 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 252 42 1 0 0;
#X restore 306 5 graph;
#X obj 4 5 cnv 15 301 42 empty empty conv~ 20 20 2 37 #e0e0e0 #000000 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1;
#X restore 3 5 graph;
#X obj 8 448 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 8 286 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 8 363 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 8 401 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X obj 152 374 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 151 295 cnv 17 3 61 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 179 220 else/out~;
#X text 117 426 2) symbol;
#X text 123 409 1) float;
#X text 181 410 -;
#X text 224 294 signal - input signal, f 39;
#X text 224 375 signal - output signal;
#X text 76 90 [conv~] is an abstraction that performs partitioned convolution. It takes a partition size and Impulse Response table., f 65;
#X obj 179 133 else/play.file~ vacuous.wav 1 1;
#X msg 199 163 print;
#X text 183 426 - impulse response table name (default none);
#N canvas 388 176 695 494 example 0;
#N canvas 144 216 913 453 partitioned-convolution-explained 0;
#X text 38 177 This is the standard frequency domain method \, which is much faster than performing convolution in the time domain. In either case \, the result is that a scaled and time shifted copy of one file takes the place of every single sample in the other. So \, if you have an impulse response (IR) of a room - that is \, a burst of noise followed by the natural echos the room produces - you can graft that pattern of echos onto every single sample in your input file.;
#X text 38 297 With real-time input \, the situation becomes more complicated. We can have an IR prepared in advance \, but the other sound source only shows up bit by bit. Typically \, it will arrive in chunks of 64 \, 128 \, 256 \, or some other number of samples. Partitioned convolution solves this problem by breaking up the IR into some number of partitions that is each M samples long. M should be the same size as the chunks of input that arrive in real time. Then \, each of the partitions is Fourier transformed and stored as frequency domain data.;
#X text 488 247 The last point to make is that the size of the Fourier transform must be M*2. That is \, when we get the latest M samples \, we pad it out with zeros to M*2 samples \, then transform it. All of the IR partitions are padded to this same size. When any one chunk is inverse Fourier transformed \, its main content will be over the first M samples \, trailed by low amplitude samples or zeros. A process of overlapping and adding is then performed so that the first M samples of the most recently processed M*2 samples is mixed down with the last M samples of the previous chunk of processed M*2 samples.;
#X text 488 27 When each new input chunk arrives (the M most recent samples) \, it is Fourier transformed into complex frequency domain data. The new chunk of frequency domain data is multiplied against each of the pre-prepared IR partitions that are also in the frequency domain. We can immediately do an inverse Fourier transform on the most recently available chunk to hear that portion of the processed input in the time domain \, but the other chunks will wait in a buffer to be output in the future. The crucial point to understand is that as new input chunks come in and are transformed and multiplied in the frequency domain \, we sum that new data with whatever other frequency domain data was waiting in that part of the buffer. Thus \, we save numerous FFT calls by summing in the frequency domain.;
#X text 38 27 With two pre-recorded sound files \, convolution is pretty simple. We determine which file is longer \, find the next highest power of 2 (we'll call it N) \, and then pad each of the files with addiontal zeros up to N. Next \, we do a forward Fourier transform on each of them \, and multiply the transformed data sets point by point. Because the data contain complex values \, we must do a complex multiply vis FOIL. After multiplication \, all that is left to do is an inverse Fourier transform on the frequency domain product. Depending on the specific FFT algorithm being used \, you may also have to scale the amplitude by the reciprocal of N.;
#X restore 375 349 pd partitioned-convolution-explained;
#X obj 59 276 else/meter;
#X floatatom 59 300 5 0 0 0 - - - 16;
#X obj 149 323 else/out~;
#X obj 78 88 else/play.file~ bubul.wav 1 1;
#X obj 391 66 else/sample~ IR IR.wav;
#X msg 183 223 set IR;
#X msg 149 136 size 256;
#X text 397 37 Loading IR tables:;
#X text 22 18 Change partition size (and latency) in samples. It must be a power of 2! Small partition sizes have less latency and are more expensive. Change it and check balow, f 48;
#X text 173 184 set IR tables;
#X msg 137 115 size 64;
#X msg 163 157 size 512;
#X obj 149 292 ./conv~ 512 IR;
#X obj 392 89 else/sample~ church church.wav;
#X msg 170 201 set church;
#X msg 188 259 print;
#X text 231 252 post info on terminal window, f 16;
#X text 259 404 don't post size when changing size;
#X text 293 449 change print posts;
#X obj 393 217 else/tabplayer~ IR;
#X obj 393 260 else/out~;
#X obj 524 181 bng 25 250 50 0 empty empty empty 0 -8 0 10 #dfdfdf #000000 #000000;
#X obj 524 259 else/out~;
#X obj 524 216 else/tabplayer~ church;
#X obj 393 181 bng 25 250 50 0 empty empty empty 0 -8 0 10 #dfdfdf #000000 #000000;
#X text 402 146 Plau IR samples:;
#X connect 1 0 2 0;
#X connect 4 0 13 0;
#X connect 6 0 13 0;
#X connect 7 0 13 0;
#X connect 11 0 13 0;
#X connect 12 0 13 0;
#X connect 13 0 3 0;
#X connect 15 0 13 0;
#X connect 16 0 13 0;
#X connect 20 0 21 0;
#X connect 22 0 24 0;
#X connect 24 0 23 0;
#X connect 25 0 20 0;
#X restore 463 248 pd example;
#X obj 179 189 ./conv~ 64 IR;
#X text 230 342 print - post info on terminal, f 38;
#X text 188 326 set <symbol> - set IR table, f 45;
#X text 188 310 size <float> - sets partition size in samples;
#X text 194 409 optional: partition size (default 256 \, minimum 64), f 53;
#X connect 25 0 29 0;
#X connect 26 0 29 0;
#X connect 29 0 18 0;
